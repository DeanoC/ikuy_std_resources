// DO NOT EDIT - Autogenerated by Overlord
const std = @import("std");

// comptime makes path absolute from this build file
pub fn sdkPath(comptime suffix: []const u8) []const u8 {
    return comptime blk: {
        const root_dir = std.fs.path.dirname(@src().file) orelse ".";
        break :blk root_dir ++ "/" ++ suffix;
    };
}

// Package definitions
const sokolPkg = std.build.Pkg{ .name = "sokol", .source = .{ .path = sdkPath("libs/sokol/build.zig") } };
const vfilePkg = std.build.Pkg{ .name = "vfile", .source = .{ .path = sdkPath("libs/vfile/package.zig") } };
const tiny_image_formatPkg = std.build.Pkg{ .name = "tiny_image_format", .source = .{ .path = sdkPath("libs/tiny_image_format/package.zig") } };

// Local program definitions
const hello_world = @import("hello_world/ikuy_build.zig");

// link functions
pub fn sokolLink(builder: *std.build.Builder, executable: *std.build.LibExeObjStep) void {
     const sokol = @import("libs/sokol/build.zig");
    executable.linkLibrary(sokol.buildSokol(builder, executable.target, builder.standardReleaseOptions(), sokol.Backend.auto, "libs/sokol/"));

    executable.addPackage(sokolPkg);
}

pub fn vfileLink(_: *std.build.Builder, executable: *std.build.LibExeObjStep) void {
    executable.addPackage(vfilePkg);
}

pub fn tiny_image_formatLink(builder: *std.build.Builder, executable: *std.build.LibExeObjStep) void {
     const tiny_image_format = @import("libs/tiny_image_format/package.zig");
    executable.step.dependOn(&tiny_image_format.buildFormatGen(builder, executable.target, builder.standardReleaseOptions(), "libs/tiny_image_format").step);

    executable.addPackage(vfilePkg);
    executable.addPackage(tiny_image_formatPkg);
}

// The actual build function
pub fn build(builder: *std.build.Builder) !void {
    const hello_world_exe = try hello_world.build(builder);
    sokolLink(builder, hello_world_exe);
    hello_world_exe.addPackage(vfilePkg);
    tiny_image_formatLink(builder, hello_world_exe);
}
